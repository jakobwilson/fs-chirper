"use strict";
(self["webpackChunkbarebones_react_typescript_express"] = self["webpackChunkbarebones_react_typescript_express"] || []).push([["vendors-node_modules_ionic_core_components_input-shims_js"],{

/***/ "./node_modules/@ionic/core/components/input-shims.js":
/*!************************************************************!*\
  !*** ./node_modules/@ionic/core/components/input-shims.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "startInputShims": () => (/* binding */ startInputShims)
/* harmony export */ });
/* harmony import */ var _index8_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./index8.js */ "./node_modules/@ionic/core/components/index8.js");
/* harmony import */ var _helpers_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers.js */ "./node_modules/@ionic/core/components/helpers.js");
/* harmony import */ var _keyboard_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./keyboard.js */ "./node_modules/@ionic/core/components/keyboard.js");
/*!
 * (C) Ionic http://ionicframework.com - MIT License
 */




const cloneMap = new WeakMap();
const relocateInput = (componentEl, inputEl, shouldRelocate, inputRelativeY = 0, disabledClonedInput = false) => {
  if (cloneMap.has(componentEl) === shouldRelocate) {
    return;
  }
  if (shouldRelocate) {
    addClone(componentEl, inputEl, inputRelativeY, disabledClonedInput);
  }
  else {
    removeClone(componentEl, inputEl);
  }
};
// TODO(FW-2832): type
const isFocused = (input) => {
  return input === input.getRootNode().activeElement;
};
const addClone = (componentEl, inputEl, inputRelativeY, disabledClonedInput = false) => {
  // this allows for the actual input to receive the focus from
  // the user's touch event, but before it receives focus, it
  // moves the actual input to a location that will not screw
  // up the app's layout, and does not allow the native browser
  // to attempt to scroll the input into place (messing up headers/footers)
  // the cloned input fills the area of where native input should be
  // while the native input fakes out the browser by relocating itself
  // before it receives the actual focus event
  // We hide the focused input (with the visible caret) invisible by making it scale(0),
  const parentEl = inputEl.parentNode;
  // DOM WRITES
  const clonedEl = inputEl.cloneNode(false);
  clonedEl.classList.add('cloned-input');
  clonedEl.tabIndex = -1;
  /**
   * Making the cloned input disabled prevents
   * Chrome for Android from still scrolling
   * the entire page since this cloned input
   * will briefly be hidden by the keyboard
   * even though it is not focused.
   *
   * This is not needed on iOS. While this
   * does not cause functional issues on iOS,
   * the input still appears slightly dimmed even
   * if we set opacity: 1.
   */
  if (disabledClonedInput) {
    clonedEl.disabled = true;
  }
  parentEl.appendChild(clonedEl);
  cloneMap.set(componentEl, clonedEl);
  const doc = componentEl.ownerDocument;
  const tx = doc.dir === 'rtl' ? 9999 : -9999;
  componentEl.style.pointerEvents = 'none';
  inputEl.style.transform = `translate3d(${tx}px,${inputRelativeY}px,0) scale(0)`;
};
const removeClone = (componentEl, inputEl) => {
  const clone = cloneMap.get(componentEl);
  if (clone) {
    cloneMap.delete(componentEl);
    clone.remove();
  }
  componentEl.style.pointerEvents = '';
  inputEl.style.transform = '';
};
/**
 * Factoring in 50px gives us some room
 * in case the keyboard shows password/autofill bars
 * asynchronously.
 */
const SCROLL_AMOUNT_PADDING = 50;

const enableHideCaretOnScroll = (componentEl, inputEl, scrollEl) => {
  if (!scrollEl || !inputEl) {
    return () => {
      return;
    };
  }
  const scrollHideCaret = (shouldHideCaret) => {
    if (isFocused(inputEl)) {
      relocateInput(componentEl, inputEl, shouldHideCaret);
    }
  };
  const onBlur = () => relocateInput(componentEl, inputEl, false);
  const hideCaret = () => scrollHideCaret(true);
  const showCaret = () => scrollHideCaret(false);
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollStart', hideCaret);
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(scrollEl, 'ionScrollEnd', showCaret);
  inputEl.addEventListener('blur', onBlur);
  return () => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollStart', hideCaret);
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(scrollEl, 'ionScrollEnd', showCaret);
    inputEl.removeEventListener('blur', onBlur);
  };
};

const SKIP_SELECTOR = 'input, textarea, [no-blur], [contenteditable]';
const enableInputBlurring = () => {
  let focused = true;
  let didScroll = false;
  const doc = document;
  const onScroll = () => {
    didScroll = true;
  };
  const onFocusin = () => {
    focused = true;
  };
  const onTouchend = (ev) => {
    // if app did scroll return early
    if (didScroll) {
      didScroll = false;
      return;
    }
    const active = doc.activeElement;
    if (!active) {
      return;
    }
    // only blur if the active element is a text-input or a textarea
    if (active.matches(SKIP_SELECTOR)) {
      return;
    }
    // if the selected target is the active element, do not blur
    const tapped = ev.target;
    if (tapped === active) {
      return;
    }
    if (tapped.matches(SKIP_SELECTOR) || tapped.closest(SKIP_SELECTOR)) {
      return;
    }
    focused = false;
    // TODO FW-2796: find a better way, why 50ms?
    setTimeout(() => {
      if (!focused) {
        active.blur();
      }
    }, 50);
  };
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.a)(doc, 'ionScrollStart', onScroll);
  doc.addEventListener('focusin', onFocusin, true);
  doc.addEventListener('touchend', onTouchend, false);
  return () => {
    (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.b)(doc, 'ionScrollStart', onScroll, true);
    doc.removeEventListener('focusin', onFocusin, true);
    doc.removeEventListener('touchend', onTouchend, false);
  };
};

const SCROLL_ASSIST_SPEED = 0.3;
const getScrollData = (componentEl, contentEl, keyboardHeight) => {
  var _a;
  const itemEl = (_a = componentEl.closest('ion-item,[ion-item]')) !== null && _a !== void 0 ? _a : componentEl;
  return calcScrollData(itemEl.getBoundingClientRect(), contentEl.getBoundingClientRect(), keyboardHeight, componentEl.ownerDocument.defaultView.innerHeight // TODO(FW-2832): type
  );
};
const calcScrollData = (inputRect, contentRect, keyboardHeight, platformHeight) => {
  // compute input's Y values relative to the body
  const inputTop = inputRect.top;
  const inputBottom = inputRect.bottom;
  // compute visible area
  const visibleAreaTop = contentRect.top;
  const visibleAreaBottom = Math.min(contentRect.bottom, platformHeight - keyboardHeight);
  // compute safe area
  const safeAreaTop = visibleAreaTop + 15;
  const safeAreaBottom = visibleAreaBottom - SCROLL_AMOUNT_PADDING;
  // figure out if each edge of the input is within the safe area
  const distanceToBottom = safeAreaBottom - inputBottom;
  const distanceToTop = safeAreaTop - inputTop;
  // desiredScrollAmount is the negated distance to the safe area according to our calculations.
  const desiredScrollAmount = Math.round(distanceToBottom < 0 ? -distanceToBottom : distanceToTop > 0 ? -distanceToTop : 0);
  // our calculations make some assumptions that aren't always true, like the keyboard being closed when an input
  // gets focus, so make sure we don't scroll the input above the visible area
  const scrollAmount = Math.min(desiredScrollAmount, inputTop - visibleAreaTop);
  const distance = Math.abs(scrollAmount);
  const duration = distance / SCROLL_ASSIST_SPEED;
  const scrollDuration = Math.min(400, Math.max(150, duration));
  return {
    scrollAmount,
    scrollDuration,
    scrollPadding: keyboardHeight,
    inputSafeY: -(inputTop - safeAreaTop) + 4,
  };
};

const PADDING_TIMER_KEY = '$ionPaddingTimer';
/**
 * Scroll padding adds additional padding to the bottom
 * of ion-content so that there is enough scroll space
 * for an input to be scrolled above the keyboard. This
 * is needed in environments where the webview does not
 * resize when the keyboard opens.
 *
 * Example: If an input at the bottom of ion-content is
 * focused, there is no additional scrolling space below
 * it, so the input cannot be scrolled above the keyboard.
 * Scroll padding fixes this by adding padding equal to the
 * height of the keyboard to the bottom of the content.
 *
 * Common environments where this is needed:
 * - Mobile Safari: The keyboard overlays the content
 * - Capacitor/Cordova on iOS: The keyboard overlays the content
 * when the KeyboardResize mode is set to 'none'.
 */
const setScrollPadding = (contentEl, paddingAmount, clearCallback) => {
  const timer = contentEl[PADDING_TIMER_KEY];
  if (timer) {
    clearTimeout(timer);
  }
  if (paddingAmount > 0) {
    contentEl.style.setProperty('--keyboard-offset', `${paddingAmount}px`);
  }
  else {
    contentEl[PADDING_TIMER_KEY] = setTimeout(() => {
      contentEl.style.setProperty('--keyboard-offset', '0px');
      if (clearCallback) {
        clearCallback();
      }
    }, 120);
  }
};
/**
 * When an input is about to be focused,
 * set a timeout to clear any scroll padding
 * on the content. Note: The clearing
 * is done on a timeout so that if users
 * are moving focus from one input to the next
 * then re-adding scroll padding to the new
 * input with cancel the timeout to clear the
 * scroll padding.
 */
const setClearScrollPaddingListener = (inputEl, contentEl, doneCallback) => {
  const clearScrollPadding = () => {
    if (contentEl) {
      setScrollPadding(contentEl, 0, doneCallback);
    }
  };
  inputEl.addEventListener('focusout', clearScrollPadding, { once: true });
};

let currentPadding = 0;
const SKIP_SCROLL_ASSIST = 'data-ionic-skip-scroll-assist';
const enableScrollAssist = (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, keyboardResize, disableClonedInput = false) => {
  /**
   * Scroll padding should only be added if:
   * 1. The global scrollPadding config option
   * is set to true.
   * 2. The native keyboard resize mode is either "none"
   * (keyboard overlays webview) or undefined (resize
   * information unavailable)
   * Resize info is available on Capacitor 4+
   */
  const addScrollPadding = enableScrollPadding && (keyboardResize === undefined || keyboardResize.mode === _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.a.None);
  /**
   * When the input is about to receive
   * focus, we need to move it to prevent
   * mobile Safari from adjusting the viewport.
   */
  const focusIn = async () => {
    /**
     * Scroll assist should not run again
     * on inputs that have been manually
     * focused inside of the scroll assist
     * implementation.
     */
    if (inputEl.hasAttribute(SKIP_SCROLL_ASSIST)) {
      inputEl.removeAttribute(SKIP_SCROLL_ASSIST);
      return;
    }
    jsSetFocus(componentEl, inputEl, contentEl, footerEl, keyboardHeight, addScrollPadding, disableClonedInput);
  };
  componentEl.addEventListener('focusin', focusIn, true);
  return () => {
    componentEl.removeEventListener('focusin', focusIn, true);
  };
};
/**
 * Use this function when you want to manually
 * focus an input but not have scroll assist run again.
 */
const setManualFocus = (el) => {
  /**
   * If element is already focused then
   * a new focusin event will not be dispatched
   * to remove the SKIL_SCROLL_ASSIST attribute.
   */
  if (document.activeElement === el) {
    return;
  }
  el.setAttribute(SKIP_SCROLL_ASSIST, 'true');
  el.focus();
};
const jsSetFocus = async (componentEl, inputEl, contentEl, footerEl, keyboardHeight, enableScrollPadding, disableClonedInput = false) => {
  if (!contentEl && !footerEl) {
    return;
  }
  const scrollData = getScrollData(componentEl, (contentEl || footerEl), keyboardHeight);
  if (contentEl && Math.abs(scrollData.scrollAmount) < 4) {
    // the text input is in a safe position that doesn't
    // require it to be scrolled into view, just set focus now
    setManualFocus(inputEl);
    /**
     * Even though the input does not need
     * scroll assist, we should preserve the
     * the scroll padding as users could be moving
     * focus from an input that needs scroll padding
     * to an input that does not need scroll padding.
     * If we remove the scroll padding now, users will
     * see the page jump.
     */
    if (enableScrollPadding && contentEl !== null) {
      setScrollPadding(contentEl, currentPadding);
      setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));
    }
    return;
  }
  // temporarily move the focus to the focus holder so the browser
  // doesn't freak out while it's trying to get the input in place
  // at this point the native text input still does not have focus
  relocateInput(componentEl, inputEl, true, scrollData.inputSafeY, disableClonedInput);
  setManualFocus(inputEl);
  /**
   * Relocating/Focusing input causes the
   * click event to be cancelled, so
   * manually fire one here.
   */
  (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.r)(() => componentEl.click());
  /**
   * If enabled, we can add scroll padding to
   * the bottom of the content so that scroll assist
   * has enough room to scroll the input above
   * the keyboard.
   */
  if (enableScrollPadding && contentEl) {
    currentPadding = scrollData.scrollPadding;
    setScrollPadding(contentEl, currentPadding);
  }
  if (typeof window !== 'undefined') {
    let scrollContentTimeout;
    const scrollContent = async () => {
      // clean up listeners and timeouts
      if (scrollContentTimeout !== undefined) {
        clearTimeout(scrollContentTimeout);
      }
      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
      window.removeEventListener('ionKeyboardDidShow', scrollContent);
      // scroll the input into place
      if (contentEl) {
        await (0,_index8_js__WEBPACK_IMPORTED_MODULE_2__.c)(contentEl, 0, scrollData.scrollAmount, scrollData.scrollDuration);
      }
      // the scroll view is in the correct position now
      // give the native text input focus
      relocateInput(componentEl, inputEl, false, scrollData.inputSafeY);
      // ensure this is the focused input
      setManualFocus(inputEl);
      /**
       * When the input is about to be blurred
       * we should set a timeout to remove
       * any scroll padding.
       */
      if (enableScrollPadding) {
        setClearScrollPaddingListener(inputEl, contentEl, () => (currentPadding = 0));
      }
    };
    const doubleKeyboardEventListener = () => {
      window.removeEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
      window.addEventListener('ionKeyboardDidShow', scrollContent);
    };
    if (contentEl) {
      const scrollEl = await (0,_index8_js__WEBPACK_IMPORTED_MODULE_2__.g)(contentEl);
      /**
       * scrollData will only consider the amount we need
       * to scroll in order to properly bring the input
       * into view. It will not consider the amount
       * we can scroll in the content element.
       * As a result, scrollData may request a greater
       * scroll position than is currently available
       * in the DOM. If this is the case, we need to
       * wait for the webview to resize/the keyboard
       * to show in order for additional scroll
       * bandwidth to become available.
       */
      const totalScrollAmount = scrollEl.scrollHeight - scrollEl.clientHeight;
      if (scrollData.scrollAmount > totalScrollAmount - scrollEl.scrollTop) {
        /**
         * On iOS devices, the system will show a "Passwords" bar above the keyboard
         * after the initial keyboard is shown. This prevents the webview from resizing
         * until the "Passwords" bar is shown, so we need to wait for that to happen first.
         */
        if (inputEl.type === 'password') {
          // Add 50px to account for the "Passwords" bar
          scrollData.scrollAmount += SCROLL_AMOUNT_PADDING;
          window.addEventListener('ionKeyboardDidShow', doubleKeyboardEventListener);
        }
        else {
          window.addEventListener('ionKeyboardDidShow', scrollContent);
        }
        /**
         * This should only fire in 2 instances:
         * 1. The app is very slow.
         * 2. The app is running in a browser on an old OS
         * that does not support Ionic Keyboard Events
         */
        scrollContentTimeout = setTimeout(scrollContent, 1000);
        return;
      }
    }
    scrollContent();
  }
};

const INPUT_BLURRING = true;
const startInputShims = async (config, platform) => {
  const doc = document;
  const isIOS = platform === 'ios';
  const isAndroid = platform === 'android';
  /**
   * Hide Caret and Input Blurring are needed on iOS.
   * Scroll Assist and Scroll Padding are needed on iOS and Android
   * with Chrome web browser (not Chrome webview).
   */
  const keyboardHeight = config.getNumber('keyboardHeight', 290);
  const scrollAssist = config.getBoolean('scrollAssist', true);
  const hideCaret = config.getBoolean('hideCaretOnScroll', isIOS);
  const inputBlurring = config.getBoolean('inputBlurring', isIOS);
  const scrollPadding = config.getBoolean('scrollPadding', true);
  const inputs = Array.from(doc.querySelectorAll('ion-input, ion-textarea'));
  const hideCaretMap = new WeakMap();
  const scrollAssistMap = new WeakMap();
  /**
   * Grab the native keyboard resize configuration
   * and pass it to scroll assist. Scroll assist requires
   * that we adjust the input right before the input
   * is about to be focused. If we called `Keyboard.getResizeMode`
   * on focusin in scroll assist, we could potentially adjust the
   * input too late since this call is async.
   */
  const keyboardResizeMode = await _keyboard_js__WEBPACK_IMPORTED_MODULE_1__.K.getResizeMode();
  const registerInput = async (componentEl) => {
    await new Promise((resolve) => (0,_helpers_js__WEBPACK_IMPORTED_MODULE_0__.c)(componentEl, resolve));
    const inputRoot = componentEl.shadowRoot || componentEl;
    const inputEl = inputRoot.querySelector('input') || inputRoot.querySelector('textarea');
    const scrollEl = (0,_index8_js__WEBPACK_IMPORTED_MODULE_2__.a)(componentEl);
    const footerEl = !scrollEl ? componentEl.closest('ion-footer') : null;
    if (!inputEl) {
      return;
    }
    if (!!scrollEl && hideCaret && !hideCaretMap.has(componentEl)) {
      const rmFn = enableHideCaretOnScroll(componentEl, inputEl, scrollEl);
      hideCaretMap.set(componentEl, rmFn);
    }
    /**
     * date/datetime-locale inputs on mobile devices show date picker
     * overlays instead of keyboards. As a result, scroll assist is
     * not needed. This also works around a bug in iOS <16 where
     * scroll assist causes the browser to lock up. See FW-1997.
     */
    const isDateInput = inputEl.type === 'date' || inputEl.type === 'datetime-local';
    if (!isDateInput &&
      (!!scrollEl || !!footerEl) &&
      scrollAssist &&
      !scrollAssistMap.has(componentEl)) {
      const rmFn = enableScrollAssist(componentEl, inputEl, scrollEl, footerEl, keyboardHeight, scrollPadding, keyboardResizeMode, isAndroid);
      scrollAssistMap.set(componentEl, rmFn);
    }
  };
  const unregisterInput = (componentEl) => {
    if (hideCaret) {
      const fn = hideCaretMap.get(componentEl);
      if (fn) {
        fn();
      }
      hideCaretMap.delete(componentEl);
    }
    if (scrollAssist) {
      const fn = scrollAssistMap.get(componentEl);
      if (fn) {
        fn();
      }
      scrollAssistMap.delete(componentEl);
    }
  };
  if (inputBlurring && INPUT_BLURRING) {
    enableInputBlurring();
  }
  // Input might be already loaded in the DOM before ion-device-hacks did.
  // At this point we need to look for all of the inputs not registered yet
  // and register them.
  for (const input of inputs) {
    registerInput(input);
  }
  // TODO(FW-2832): types
  doc.addEventListener('ionInputDidLoad', ((ev) => {
    registerInput(ev.detail);
  }));
  doc.addEventListener('ionInputDidUnload', ((ev) => {
    unregisterInput(ev.detail);
  }));
};




/***/ })

}]);
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidmVuZG9ycy1ub2RlX21vZHVsZXNfaW9uaWNfY29yZV9jb21wb25lbnRzX2lucHV0LXNoaW1zX2pzLmFwcC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ29HO0FBQ1k7QUFDN0M7O0FBRW5FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxHQUFHLEtBQUssZUFBZTtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSw4Q0FBZ0I7QUFDbEIsRUFBRSw4Q0FBZ0I7QUFDbEI7QUFDQTtBQUNBLElBQUksOENBQW1CO0FBQ3ZCLElBQUksOENBQW1CO0FBQ3ZCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxFQUFFLDhDQUFnQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSxJQUFJLDhDQUFtQjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELGNBQWM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFlBQVk7QUFDekU7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHLGdEQUFtQjtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsOENBQUc7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZDQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsNkNBQWdCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMseURBQXNCO0FBQ3pEO0FBQ0EsbUNBQW1DLDhDQUFnQjtBQUNuRDtBQUNBO0FBQ0EscUJBQXFCLDZDQUFxQjtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9iYXJlYm9uZXMtcmVhY3QtdHlwZXNjcmlwdC1leHByZXNzLy4vbm9kZV9tb2R1bGVzL0Bpb25pYy9jb3JlL2NvbXBvbmVudHMvaW5wdXQtc2hpbXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyohXG4gKiAoQykgSW9uaWMgaHR0cDovL2lvbmljZnJhbWV3b3JrLmNvbSAtIE1JVCBMaWNlbnNlXG4gKi9cbmltcG9ydCB7IGcgYXMgZ2V0U2Nyb2xsRWxlbWVudCwgYyBhcyBzY3JvbGxCeVBvaW50LCBhIGFzIGZpbmRDbG9zZXN0SW9uQ29udGVudCB9IGZyb20gJy4vaW5kZXg4LmpzJztcbmltcG9ydCB7IGEgYXMgYWRkRXZlbnRMaXN0ZW5lciwgYiBhcyByZW1vdmVFdmVudExpc3RlbmVyLCByIGFzIHJhZiwgYyBhcyBjb21wb25lbnRPblJlYWR5IH0gZnJvbSAnLi9oZWxwZXJzLmpzJztcbmltcG9ydCB7IGEgYXMgS2V5Ym9hcmRSZXNpemUsIEsgYXMgS2V5Ym9hcmQgfSBmcm9tICcuL2tleWJvYXJkLmpzJztcblxuY29uc3QgY2xvbmVNYXAgPSBuZXcgV2Vha01hcCgpO1xuY29uc3QgcmVsb2NhdGVJbnB1dCA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2hvdWxkUmVsb2NhdGUsIGlucHV0UmVsYXRpdmVZID0gMCwgZGlzYWJsZWRDbG9uZWRJbnB1dCA9IGZhbHNlKSA9PiB7XG4gIGlmIChjbG9uZU1hcC5oYXMoY29tcG9uZW50RWwpID09PSBzaG91bGRSZWxvY2F0ZSkge1xuICAgIHJldHVybjtcbiAgfVxuICBpZiAoc2hvdWxkUmVsb2NhdGUpIHtcbiAgICBhZGRDbG9uZShjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVksIGRpc2FibGVkQ2xvbmVkSW5wdXQpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJlbW92ZUNsb25lKGNvbXBvbmVudEVsLCBpbnB1dEVsKTtcbiAgfVxufTtcbi8vIFRPRE8oRlctMjgzMik6IHR5cGVcbmNvbnN0IGlzRm9jdXNlZCA9IChpbnB1dCkgPT4ge1xuICByZXR1cm4gaW5wdXQgPT09IGlucHV0LmdldFJvb3ROb2RlKCkuYWN0aXZlRWxlbWVudDtcbn07XG5jb25zdCBhZGRDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCwgaW5wdXRSZWxhdGl2ZVksIGRpc2FibGVkQ2xvbmVkSW5wdXQgPSBmYWxzZSkgPT4ge1xuICAvLyB0aGlzIGFsbG93cyBmb3IgdGhlIGFjdHVhbCBpbnB1dCB0byByZWNlaXZlIHRoZSBmb2N1cyBmcm9tXG4gIC8vIHRoZSB1c2VyJ3MgdG91Y2ggZXZlbnQsIGJ1dCBiZWZvcmUgaXQgcmVjZWl2ZXMgZm9jdXMsIGl0XG4gIC8vIG1vdmVzIHRoZSBhY3R1YWwgaW5wdXQgdG8gYSBsb2NhdGlvbiB0aGF0IHdpbGwgbm90IHNjcmV3XG4gIC8vIHVwIHRoZSBhcHAncyBsYXlvdXQsIGFuZCBkb2VzIG5vdCBhbGxvdyB0aGUgbmF0aXZlIGJyb3dzZXJcbiAgLy8gdG8gYXR0ZW1wdCB0byBzY3JvbGwgdGhlIGlucHV0IGludG8gcGxhY2UgKG1lc3NpbmcgdXAgaGVhZGVycy9mb290ZXJzKVxuICAvLyB0aGUgY2xvbmVkIGlucHV0IGZpbGxzIHRoZSBhcmVhIG9mIHdoZXJlIG5hdGl2ZSBpbnB1dCBzaG91bGQgYmVcbiAgLy8gd2hpbGUgdGhlIG5hdGl2ZSBpbnB1dCBmYWtlcyBvdXQgdGhlIGJyb3dzZXIgYnkgcmVsb2NhdGluZyBpdHNlbGZcbiAgLy8gYmVmb3JlIGl0IHJlY2VpdmVzIHRoZSBhY3R1YWwgZm9jdXMgZXZlbnRcbiAgLy8gV2UgaGlkZSB0aGUgZm9jdXNlZCBpbnB1dCAod2l0aCB0aGUgdmlzaWJsZSBjYXJldCkgaW52aXNpYmxlIGJ5IG1ha2luZyBpdCBzY2FsZSgwKSxcbiAgY29uc3QgcGFyZW50RWwgPSBpbnB1dEVsLnBhcmVudE5vZGU7XG4gIC8vIERPTSBXUklURVNcbiAgY29uc3QgY2xvbmVkRWwgPSBpbnB1dEVsLmNsb25lTm9kZShmYWxzZSk7XG4gIGNsb25lZEVsLmNsYXNzTGlzdC5hZGQoJ2Nsb25lZC1pbnB1dCcpO1xuICBjbG9uZWRFbC50YWJJbmRleCA9IC0xO1xuICAvKipcbiAgICogTWFraW5nIHRoZSBjbG9uZWQgaW5wdXQgZGlzYWJsZWQgcHJldmVudHNcbiAgICogQ2hyb21lIGZvciBBbmRyb2lkIGZyb20gc3RpbGwgc2Nyb2xsaW5nXG4gICAqIHRoZSBlbnRpcmUgcGFnZSBzaW5jZSB0aGlzIGNsb25lZCBpbnB1dFxuICAgKiB3aWxsIGJyaWVmbHkgYmUgaGlkZGVuIGJ5IHRoZSBrZXlib2FyZFxuICAgKiBldmVuIHRob3VnaCBpdCBpcyBub3QgZm9jdXNlZC5cbiAgICpcbiAgICogVGhpcyBpcyBub3QgbmVlZGVkIG9uIGlPUy4gV2hpbGUgdGhpc1xuICAgKiBkb2VzIG5vdCBjYXVzZSBmdW5jdGlvbmFsIGlzc3VlcyBvbiBpT1MsXG4gICAqIHRoZSBpbnB1dCBzdGlsbCBhcHBlYXJzIHNsaWdodGx5IGRpbW1lZCBldmVuXG4gICAqIGlmIHdlIHNldCBvcGFjaXR5OiAxLlxuICAgKi9cbiAgaWYgKGRpc2FibGVkQ2xvbmVkSW5wdXQpIHtcbiAgICBjbG9uZWRFbC5kaXNhYmxlZCA9IHRydWU7XG4gIH1cbiAgcGFyZW50RWwuYXBwZW5kQ2hpbGQoY2xvbmVkRWwpO1xuICBjbG9uZU1hcC5zZXQoY29tcG9uZW50RWwsIGNsb25lZEVsKTtcbiAgY29uc3QgZG9jID0gY29tcG9uZW50RWwub3duZXJEb2N1bWVudDtcbiAgY29uc3QgdHggPSBkb2MuZGlyID09PSAncnRsJyA/IDk5OTkgOiAtOTk5OTtcbiAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICdub25lJztcbiAgaW5wdXRFbC5zdHlsZS50cmFuc2Zvcm0gPSBgdHJhbnNsYXRlM2QoJHt0eH1weCwke2lucHV0UmVsYXRpdmVZfXB4LDApIHNjYWxlKDApYDtcbn07XG5jb25zdCByZW1vdmVDbG9uZSA9IChjb21wb25lbnRFbCwgaW5wdXRFbCkgPT4ge1xuICBjb25zdCBjbG9uZSA9IGNsb25lTWFwLmdldChjb21wb25lbnRFbCk7XG4gIGlmIChjbG9uZSkge1xuICAgIGNsb25lTWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgY2xvbmUucmVtb3ZlKCk7XG4gIH1cbiAgY29tcG9uZW50RWwuc3R5bGUucG9pbnRlckV2ZW50cyA9ICcnO1xuICBpbnB1dEVsLnN0eWxlLnRyYW5zZm9ybSA9ICcnO1xufTtcbi8qKlxuICogRmFjdG9yaW5nIGluIDUwcHggZ2l2ZXMgdXMgc29tZSByb29tXG4gKiBpbiBjYXNlIHRoZSBrZXlib2FyZCBzaG93cyBwYXNzd29yZC9hdXRvZmlsbCBiYXJzXG4gKiBhc3luY2hyb25vdXNseS5cbiAqL1xuY29uc3QgU0NST0xMX0FNT1VOVF9QQURESU5HID0gNTA7XG5cbmNvbnN0IGVuYWJsZUhpZGVDYXJldE9uU2Nyb2xsID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzY3JvbGxFbCkgPT4ge1xuICBpZiAoIXNjcm9sbEVsIHx8ICFpbnB1dEVsKSB7XG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIHJldHVybjtcbiAgICB9O1xuICB9XG4gIGNvbnN0IHNjcm9sbEhpZGVDYXJldCA9IChzaG91bGRIaWRlQ2FyZXQpID0+IHtcbiAgICBpZiAoaXNGb2N1c2VkKGlucHV0RWwpKSB7XG4gICAgICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCBzaG91bGRIaWRlQ2FyZXQpO1xuICAgIH1cbiAgfTtcbiAgY29uc3Qgb25CbHVyID0gKCkgPT4gcmVsb2NhdGVJbnB1dChjb21wb25lbnRFbCwgaW5wdXRFbCwgZmFsc2UpO1xuICBjb25zdCBoaWRlQ2FyZXQgPSAoKSA9PiBzY3JvbGxIaWRlQ2FyZXQodHJ1ZSk7XG4gIGNvbnN0IHNob3dDYXJldCA9ICgpID0+IHNjcm9sbEhpZGVDYXJldChmYWxzZSk7XG4gIGFkZEV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxTdGFydCcsIGhpZGVDYXJldCk7XG4gIGFkZEV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxFbmQnLCBzaG93Q2FyZXQpO1xuICBpbnB1dEVsLmFkZEV2ZW50TGlzdGVuZXIoJ2JsdXInLCBvbkJsdXIpO1xuICByZXR1cm4gKCkgPT4ge1xuICAgIHJlbW92ZUV2ZW50TGlzdGVuZXIoc2Nyb2xsRWwsICdpb25TY3JvbGxTdGFydCcsIGhpZGVDYXJldCk7XG4gICAgcmVtb3ZlRXZlbnRMaXN0ZW5lcihzY3JvbGxFbCwgJ2lvblNjcm9sbEVuZCcsIHNob3dDYXJldCk7XG4gICAgaW5wdXRFbC5yZW1vdmVFdmVudExpc3RlbmVyKCdibHVyJywgb25CbHVyKTtcbiAgfTtcbn07XG5cbmNvbnN0IFNLSVBfU0VMRUNUT1IgPSAnaW5wdXQsIHRleHRhcmVhLCBbbm8tYmx1cl0sIFtjb250ZW50ZWRpdGFibGVdJztcbmNvbnN0IGVuYWJsZUlucHV0Qmx1cnJpbmcgPSAoKSA9PiB7XG4gIGxldCBmb2N1c2VkID0gdHJ1ZTtcbiAgbGV0IGRpZFNjcm9sbCA9IGZhbHNlO1xuICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgY29uc3Qgb25TY3JvbGwgPSAoKSA9PiB7XG4gICAgZGlkU2Nyb2xsID0gdHJ1ZTtcbiAgfTtcbiAgY29uc3Qgb25Gb2N1c2luID0gKCkgPT4ge1xuICAgIGZvY3VzZWQgPSB0cnVlO1xuICB9O1xuICBjb25zdCBvblRvdWNoZW5kID0gKGV2KSA9PiB7XG4gICAgLy8gaWYgYXBwIGRpZCBzY3JvbGwgcmV0dXJuIGVhcmx5XG4gICAgaWYgKGRpZFNjcm9sbCkge1xuICAgICAgZGlkU2Nyb2xsID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFjdGl2ZSA9IGRvYy5hY3RpdmVFbGVtZW50O1xuICAgIGlmICghYWN0aXZlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIC8vIG9ubHkgYmx1ciBpZiB0aGUgYWN0aXZlIGVsZW1lbnQgaXMgYSB0ZXh0LWlucHV0IG9yIGEgdGV4dGFyZWFcbiAgICBpZiAoYWN0aXZlLm1hdGNoZXMoU0tJUF9TRUxFQ1RPUikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgLy8gaWYgdGhlIHNlbGVjdGVkIHRhcmdldCBpcyB0aGUgYWN0aXZlIGVsZW1lbnQsIGRvIG5vdCBibHVyXG4gICAgY29uc3QgdGFwcGVkID0gZXYudGFyZ2V0O1xuICAgIGlmICh0YXBwZWQgPT09IGFjdGl2ZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGFwcGVkLm1hdGNoZXMoU0tJUF9TRUxFQ1RPUikgfHwgdGFwcGVkLmNsb3Nlc3QoU0tJUF9TRUxFQ1RPUikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9jdXNlZCA9IGZhbHNlO1xuICAgIC8vIFRPRE8gRlctMjc5NjogZmluZCBhIGJldHRlciB3YXksIHdoeSA1MG1zP1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgaWYgKCFmb2N1c2VkKSB7XG4gICAgICAgIGFjdGl2ZS5ibHVyKCk7XG4gICAgICB9XG4gICAgfSwgNTApO1xuICB9O1xuICBhZGRFdmVudExpc3RlbmVyKGRvYywgJ2lvblNjcm9sbFN0YXJ0Jywgb25TY3JvbGwpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIG9uRm9jdXNpbiwgdHJ1ZSk7XG4gIGRvYy5hZGRFdmVudExpc3RlbmVyKCd0b3VjaGVuZCcsIG9uVG91Y2hlbmQsIGZhbHNlKTtcbiAgcmV0dXJuICgpID0+IHtcbiAgICByZW1vdmVFdmVudExpc3RlbmVyKGRvYywgJ2lvblNjcm9sbFN0YXJ0Jywgb25TY3JvbGwsIHRydWUpO1xuICAgIGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgb25Gb2N1c2luLCB0cnVlKTtcbiAgICBkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBvblRvdWNoZW5kLCBmYWxzZSk7XG4gIH07XG59O1xuXG5jb25zdCBTQ1JPTExfQVNTSVNUX1NQRUVEID0gMC4zO1xuY29uc3QgZ2V0U2Nyb2xsRGF0YSA9IChjb21wb25lbnRFbCwgY29udGVudEVsLCBrZXlib2FyZEhlaWdodCkgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IGl0ZW1FbCA9IChfYSA9IGNvbXBvbmVudEVsLmNsb3Nlc3QoJ2lvbi1pdGVtLFtpb24taXRlbV0nKSkgIT09IG51bGwgJiYgX2EgIT09IHZvaWQgMCA/IF9hIDogY29tcG9uZW50RWw7XG4gIHJldHVybiBjYWxjU2Nyb2xsRGF0YShpdGVtRWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksIGNvbnRlbnRFbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSwga2V5Ym9hcmRIZWlnaHQsIGNvbXBvbmVudEVsLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcuaW5uZXJIZWlnaHQgLy8gVE9ETyhGVy0yODMyKTogdHlwZVxuICApO1xufTtcbmNvbnN0IGNhbGNTY3JvbGxEYXRhID0gKGlucHV0UmVjdCwgY29udGVudFJlY3QsIGtleWJvYXJkSGVpZ2h0LCBwbGF0Zm9ybUhlaWdodCkgPT4ge1xuICAvLyBjb21wdXRlIGlucHV0J3MgWSB2YWx1ZXMgcmVsYXRpdmUgdG8gdGhlIGJvZHlcbiAgY29uc3QgaW5wdXRUb3AgPSBpbnB1dFJlY3QudG9wO1xuICBjb25zdCBpbnB1dEJvdHRvbSA9IGlucHV0UmVjdC5ib3R0b207XG4gIC8vIGNvbXB1dGUgdmlzaWJsZSBhcmVhXG4gIGNvbnN0IHZpc2libGVBcmVhVG9wID0gY29udGVudFJlY3QudG9wO1xuICBjb25zdCB2aXNpYmxlQXJlYUJvdHRvbSA9IE1hdGgubWluKGNvbnRlbnRSZWN0LmJvdHRvbSwgcGxhdGZvcm1IZWlnaHQgLSBrZXlib2FyZEhlaWdodCk7XG4gIC8vIGNvbXB1dGUgc2FmZSBhcmVhXG4gIGNvbnN0IHNhZmVBcmVhVG9wID0gdmlzaWJsZUFyZWFUb3AgKyAxNTtcbiAgY29uc3Qgc2FmZUFyZWFCb3R0b20gPSB2aXNpYmxlQXJlYUJvdHRvbSAtIFNDUk9MTF9BTU9VTlRfUEFERElORztcbiAgLy8gZmlndXJlIG91dCBpZiBlYWNoIGVkZ2Ugb2YgdGhlIGlucHV0IGlzIHdpdGhpbiB0aGUgc2FmZSBhcmVhXG4gIGNvbnN0IGRpc3RhbmNlVG9Cb3R0b20gPSBzYWZlQXJlYUJvdHRvbSAtIGlucHV0Qm90dG9tO1xuICBjb25zdCBkaXN0YW5jZVRvVG9wID0gc2FmZUFyZWFUb3AgLSBpbnB1dFRvcDtcbiAgLy8gZGVzaXJlZFNjcm9sbEFtb3VudCBpcyB0aGUgbmVnYXRlZCBkaXN0YW5jZSB0byB0aGUgc2FmZSBhcmVhIGFjY29yZGluZyB0byBvdXIgY2FsY3VsYXRpb25zLlxuICBjb25zdCBkZXNpcmVkU2Nyb2xsQW1vdW50ID0gTWF0aC5yb3VuZChkaXN0YW5jZVRvQm90dG9tIDwgMCA/IC1kaXN0YW5jZVRvQm90dG9tIDogZGlzdGFuY2VUb1RvcCA+IDAgPyAtZGlzdGFuY2VUb1RvcCA6IDApO1xuICAvLyBvdXIgY2FsY3VsYXRpb25zIG1ha2Ugc29tZSBhc3N1bXB0aW9ucyB0aGF0IGFyZW4ndCBhbHdheXMgdHJ1ZSwgbGlrZSB0aGUga2V5Ym9hcmQgYmVpbmcgY2xvc2VkIHdoZW4gYW4gaW5wdXRcbiAgLy8gZ2V0cyBmb2N1cywgc28gbWFrZSBzdXJlIHdlIGRvbid0IHNjcm9sbCB0aGUgaW5wdXQgYWJvdmUgdGhlIHZpc2libGUgYXJlYVxuICBjb25zdCBzY3JvbGxBbW91bnQgPSBNYXRoLm1pbihkZXNpcmVkU2Nyb2xsQW1vdW50LCBpbnB1dFRvcCAtIHZpc2libGVBcmVhVG9wKTtcbiAgY29uc3QgZGlzdGFuY2UgPSBNYXRoLmFicyhzY3JvbGxBbW91bnQpO1xuICBjb25zdCBkdXJhdGlvbiA9IGRpc3RhbmNlIC8gU0NST0xMX0FTU0lTVF9TUEVFRDtcbiAgY29uc3Qgc2Nyb2xsRHVyYXRpb24gPSBNYXRoLm1pbig0MDAsIE1hdGgubWF4KDE1MCwgZHVyYXRpb24pKTtcbiAgcmV0dXJuIHtcbiAgICBzY3JvbGxBbW91bnQsXG4gICAgc2Nyb2xsRHVyYXRpb24sXG4gICAgc2Nyb2xsUGFkZGluZzoga2V5Ym9hcmRIZWlnaHQsXG4gICAgaW5wdXRTYWZlWTogLShpbnB1dFRvcCAtIHNhZmVBcmVhVG9wKSArIDQsXG4gIH07XG59O1xuXG5jb25zdCBQQURESU5HX1RJTUVSX0tFWSA9ICckaW9uUGFkZGluZ1RpbWVyJztcbi8qKlxuICogU2Nyb2xsIHBhZGRpbmcgYWRkcyBhZGRpdGlvbmFsIHBhZGRpbmcgdG8gdGhlIGJvdHRvbVxuICogb2YgaW9uLWNvbnRlbnQgc28gdGhhdCB0aGVyZSBpcyBlbm91Z2ggc2Nyb2xsIHNwYWNlXG4gKiBmb3IgYW4gaW5wdXQgdG8gYmUgc2Nyb2xsZWQgYWJvdmUgdGhlIGtleWJvYXJkLiBUaGlzXG4gKiBpcyBuZWVkZWQgaW4gZW52aXJvbm1lbnRzIHdoZXJlIHRoZSB3ZWJ2aWV3IGRvZXMgbm90XG4gKiByZXNpemUgd2hlbiB0aGUga2V5Ym9hcmQgb3BlbnMuXG4gKlxuICogRXhhbXBsZTogSWYgYW4gaW5wdXQgYXQgdGhlIGJvdHRvbSBvZiBpb24tY29udGVudCBpc1xuICogZm9jdXNlZCwgdGhlcmUgaXMgbm8gYWRkaXRpb25hbCBzY3JvbGxpbmcgc3BhY2UgYmVsb3dcbiAqIGl0LCBzbyB0aGUgaW5wdXQgY2Fubm90IGJlIHNjcm9sbGVkIGFib3ZlIHRoZSBrZXlib2FyZC5cbiAqIFNjcm9sbCBwYWRkaW5nIGZpeGVzIHRoaXMgYnkgYWRkaW5nIHBhZGRpbmcgZXF1YWwgdG8gdGhlXG4gKiBoZWlnaHQgb2YgdGhlIGtleWJvYXJkIHRvIHRoZSBib3R0b20gb2YgdGhlIGNvbnRlbnQuXG4gKlxuICogQ29tbW9uIGVudmlyb25tZW50cyB3aGVyZSB0aGlzIGlzIG5lZWRlZDpcbiAqIC0gTW9iaWxlIFNhZmFyaTogVGhlIGtleWJvYXJkIG92ZXJsYXlzIHRoZSBjb250ZW50XG4gKiAtIENhcGFjaXRvci9Db3Jkb3ZhIG9uIGlPUzogVGhlIGtleWJvYXJkIG92ZXJsYXlzIHRoZSBjb250ZW50XG4gKiB3aGVuIHRoZSBLZXlib2FyZFJlc2l6ZSBtb2RlIGlzIHNldCB0byAnbm9uZScuXG4gKi9cbmNvbnN0IHNldFNjcm9sbFBhZGRpbmcgPSAoY29udGVudEVsLCBwYWRkaW5nQW1vdW50LCBjbGVhckNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IHRpbWVyID0gY29udGVudEVsW1BBRERJTkdfVElNRVJfS0VZXTtcbiAgaWYgKHRpbWVyKSB7XG4gICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgfVxuICBpZiAocGFkZGluZ0Ftb3VudCA+IDApIHtcbiAgICBjb250ZW50RWwuc3R5bGUuc2V0UHJvcGVydHkoJy0ta2V5Ym9hcmQtb2Zmc2V0JywgYCR7cGFkZGluZ0Ftb3VudH1weGApO1xuICB9XG4gIGVsc2Uge1xuICAgIGNvbnRlbnRFbFtQQURESU5HX1RJTUVSX0tFWV0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIGNvbnRlbnRFbC5zdHlsZS5zZXRQcm9wZXJ0eSgnLS1rZXlib2FyZC1vZmZzZXQnLCAnMHB4Jyk7XG4gICAgICBpZiAoY2xlYXJDYWxsYmFjaykge1xuICAgICAgICBjbGVhckNhbGxiYWNrKCk7XG4gICAgICB9XG4gICAgfSwgMTIwKTtcbiAgfVxufTtcbi8qKlxuICogV2hlbiBhbiBpbnB1dCBpcyBhYm91dCB0byBiZSBmb2N1c2VkLFxuICogc2V0IGEgdGltZW91dCB0byBjbGVhciBhbnkgc2Nyb2xsIHBhZGRpbmdcbiAqIG9uIHRoZSBjb250ZW50LiBOb3RlOiBUaGUgY2xlYXJpbmdcbiAqIGlzIGRvbmUgb24gYSB0aW1lb3V0IHNvIHRoYXQgaWYgdXNlcnNcbiAqIGFyZSBtb3ZpbmcgZm9jdXMgZnJvbSBvbmUgaW5wdXQgdG8gdGhlIG5leHRcbiAqIHRoZW4gcmUtYWRkaW5nIHNjcm9sbCBwYWRkaW5nIHRvIHRoZSBuZXdcbiAqIGlucHV0IHdpdGggY2FuY2VsIHRoZSB0aW1lb3V0IHRvIGNsZWFyIHRoZVxuICogc2Nyb2xsIHBhZGRpbmcuXG4gKi9cbmNvbnN0IHNldENsZWFyU2Nyb2xsUGFkZGluZ0xpc3RlbmVyID0gKGlucHV0RWwsIGNvbnRlbnRFbCwgZG9uZUNhbGxiYWNrKSA9PiB7XG4gIGNvbnN0IGNsZWFyU2Nyb2xsUGFkZGluZyA9ICgpID0+IHtcbiAgICBpZiAoY29udGVudEVsKSB7XG4gICAgICBzZXRTY3JvbGxQYWRkaW5nKGNvbnRlbnRFbCwgMCwgZG9uZUNhbGxiYWNrKTtcbiAgICB9XG4gIH07XG4gIGlucHV0RWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCBjbGVhclNjcm9sbFBhZGRpbmcsIHsgb25jZTogdHJ1ZSB9KTtcbn07XG5cbmxldCBjdXJyZW50UGFkZGluZyA9IDA7XG5jb25zdCBTS0lQX1NDUk9MTF9BU1NJU1QgPSAnZGF0YS1pb25pYy1za2lwLXNjcm9sbC1hc3Npc3QnO1xuY29uc3QgZW5hYmxlU2Nyb2xsQXNzaXN0ID0gKGNvbXBvbmVudEVsLCBpbnB1dEVsLCBjb250ZW50RWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgZW5hYmxlU2Nyb2xsUGFkZGluZywga2V5Ym9hcmRSZXNpemUsIGRpc2FibGVDbG9uZWRJbnB1dCA9IGZhbHNlKSA9PiB7XG4gIC8qKlxuICAgKiBTY3JvbGwgcGFkZGluZyBzaG91bGQgb25seSBiZSBhZGRlZCBpZjpcbiAgICogMS4gVGhlIGdsb2JhbCBzY3JvbGxQYWRkaW5nIGNvbmZpZyBvcHRpb25cbiAgICogaXMgc2V0IHRvIHRydWUuXG4gICAqIDIuIFRoZSBuYXRpdmUga2V5Ym9hcmQgcmVzaXplIG1vZGUgaXMgZWl0aGVyIFwibm9uZVwiXG4gICAqIChrZXlib2FyZCBvdmVybGF5cyB3ZWJ2aWV3KSBvciB1bmRlZmluZWQgKHJlc2l6ZVxuICAgKiBpbmZvcm1hdGlvbiB1bmF2YWlsYWJsZSlcbiAgICogUmVzaXplIGluZm8gaXMgYXZhaWxhYmxlIG9uIENhcGFjaXRvciA0K1xuICAgKi9cbiAgY29uc3QgYWRkU2Nyb2xsUGFkZGluZyA9IGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgKGtleWJvYXJkUmVzaXplID09PSB1bmRlZmluZWQgfHwga2V5Ym9hcmRSZXNpemUubW9kZSA9PT0gS2V5Ym9hcmRSZXNpemUuTm9uZSk7XG4gIC8qKlxuICAgKiBXaGVuIHRoZSBpbnB1dCBpcyBhYm91dCB0byByZWNlaXZlXG4gICAqIGZvY3VzLCB3ZSBuZWVkIHRvIG1vdmUgaXQgdG8gcHJldmVudFxuICAgKiBtb2JpbGUgU2FmYXJpIGZyb20gYWRqdXN0aW5nIHRoZSB2aWV3cG9ydC5cbiAgICovXG4gIGNvbnN0IGZvY3VzSW4gPSBhc3luYyAoKSA9PiB7XG4gICAgLyoqXG4gICAgICogU2Nyb2xsIGFzc2lzdCBzaG91bGQgbm90IHJ1biBhZ2FpblxuICAgICAqIG9uIGlucHV0cyB0aGF0IGhhdmUgYmVlbiBtYW51YWxseVxuICAgICAqIGZvY3VzZWQgaW5zaWRlIG9mIHRoZSBzY3JvbGwgYXNzaXN0XG4gICAgICogaW1wbGVtZW50YXRpb24uXG4gICAgICovXG4gICAgaWYgKGlucHV0RWwuaGFzQXR0cmlidXRlKFNLSVBfU0NST0xMX0FTU0lTVCkpIHtcbiAgICAgIGlucHV0RWwucmVtb3ZlQXR0cmlidXRlKFNLSVBfU0NST0xMX0FTU0lTVCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGpzU2V0Rm9jdXMoY29tcG9uZW50RWwsIGlucHV0RWwsIGNvbnRlbnRFbCwgZm9vdGVyRWwsIGtleWJvYXJkSGVpZ2h0LCBhZGRTY3JvbGxQYWRkaW5nLCBkaXNhYmxlQ2xvbmVkSW5wdXQpO1xuICB9O1xuICBjb21wb25lbnRFbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgZm9jdXNJbiwgdHJ1ZSk7XG4gIHJldHVybiAoKSA9PiB7XG4gICAgY29tcG9uZW50RWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNpbicsIGZvY3VzSW4sIHRydWUpO1xuICB9O1xufTtcbi8qKlxuICogVXNlIHRoaXMgZnVuY3Rpb24gd2hlbiB5b3Ugd2FudCB0byBtYW51YWxseVxuICogZm9jdXMgYW4gaW5wdXQgYnV0IG5vdCBoYXZlIHNjcm9sbCBhc3Npc3QgcnVuIGFnYWluLlxuICovXG5jb25zdCBzZXRNYW51YWxGb2N1cyA9IChlbCkgPT4ge1xuICAvKipcbiAgICogSWYgZWxlbWVudCBpcyBhbHJlYWR5IGZvY3VzZWQgdGhlblxuICAgKiBhIG5ldyBmb2N1c2luIGV2ZW50IHdpbGwgbm90IGJlIGRpc3BhdGNoZWRcbiAgICogdG8gcmVtb3ZlIHRoZSBTS0lMX1NDUk9MTF9BU1NJU1QgYXR0cmlidXRlLlxuICAgKi9cbiAgaWYgKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgPT09IGVsKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGVsLnNldEF0dHJpYnV0ZShTS0lQX1NDUk9MTF9BU1NJU1QsICd0cnVlJyk7XG4gIGVsLmZvY3VzKCk7XG59O1xuY29uc3QganNTZXRGb2N1cyA9IGFzeW5jIChjb21wb25lbnRFbCwgaW5wdXRFbCwgY29udGVudEVsLCBmb290ZXJFbCwga2V5Ym9hcmRIZWlnaHQsIGVuYWJsZVNjcm9sbFBhZGRpbmcsIGRpc2FibGVDbG9uZWRJbnB1dCA9IGZhbHNlKSA9PiB7XG4gIGlmICghY29udGVudEVsICYmICFmb290ZXJFbCkge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBzY3JvbGxEYXRhID0gZ2V0U2Nyb2xsRGF0YShjb21wb25lbnRFbCwgKGNvbnRlbnRFbCB8fCBmb290ZXJFbCksIGtleWJvYXJkSGVpZ2h0KTtcbiAgaWYgKGNvbnRlbnRFbCAmJiBNYXRoLmFicyhzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCkgPCA0KSB7XG4gICAgLy8gdGhlIHRleHQgaW5wdXQgaXMgaW4gYSBzYWZlIHBvc2l0aW9uIHRoYXQgZG9lc24ndFxuICAgIC8vIHJlcXVpcmUgaXQgdG8gYmUgc2Nyb2xsZWQgaW50byB2aWV3LCBqdXN0IHNldCBmb2N1cyBub3dcbiAgICBzZXRNYW51YWxGb2N1cyhpbnB1dEVsKTtcbiAgICAvKipcbiAgICAgKiBFdmVuIHRob3VnaCB0aGUgaW5wdXQgZG9lcyBub3QgbmVlZFxuICAgICAqIHNjcm9sbCBhc3Npc3QsIHdlIHNob3VsZCBwcmVzZXJ2ZSB0aGVcbiAgICAgKiB0aGUgc2Nyb2xsIHBhZGRpbmcgYXMgdXNlcnMgY291bGQgYmUgbW92aW5nXG4gICAgICogZm9jdXMgZnJvbSBhbiBpbnB1dCB0aGF0IG5lZWRzIHNjcm9sbCBwYWRkaW5nXG4gICAgICogdG8gYW4gaW5wdXQgdGhhdCBkb2VzIG5vdCBuZWVkIHNjcm9sbCBwYWRkaW5nLlxuICAgICAqIElmIHdlIHJlbW92ZSB0aGUgc2Nyb2xsIHBhZGRpbmcgbm93LCB1c2VycyB3aWxsXG4gICAgICogc2VlIHRoZSBwYWdlIGp1bXAuXG4gICAgICovXG4gICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgY29udGVudEVsICE9PSBudWxsKSB7XG4gICAgICBzZXRTY3JvbGxQYWRkaW5nKGNvbnRlbnRFbCwgY3VycmVudFBhZGRpbmcpO1xuICAgICAgc2V0Q2xlYXJTY3JvbGxQYWRkaW5nTGlzdGVuZXIoaW5wdXRFbCwgY29udGVudEVsLCAoKSA9PiAoY3VycmVudFBhZGRpbmcgPSAwKSk7XG4gICAgfVxuICAgIHJldHVybjtcbiAgfVxuICAvLyB0ZW1wb3JhcmlseSBtb3ZlIHRoZSBmb2N1cyB0byB0aGUgZm9jdXMgaG9sZGVyIHNvIHRoZSBicm93c2VyXG4gIC8vIGRvZXNuJ3QgZnJlYWsgb3V0IHdoaWxlIGl0J3MgdHJ5aW5nIHRvIGdldCB0aGUgaW5wdXQgaW4gcGxhY2VcbiAgLy8gYXQgdGhpcyBwb2ludCB0aGUgbmF0aXZlIHRleHQgaW5wdXQgc3RpbGwgZG9lcyBub3QgaGF2ZSBmb2N1c1xuICByZWxvY2F0ZUlucHV0KGNvbXBvbmVudEVsLCBpbnB1dEVsLCB0cnVlLCBzY3JvbGxEYXRhLmlucHV0U2FmZVksIGRpc2FibGVDbG9uZWRJbnB1dCk7XG4gIHNldE1hbnVhbEZvY3VzKGlucHV0RWwpO1xuICAvKipcbiAgICogUmVsb2NhdGluZy9Gb2N1c2luZyBpbnB1dCBjYXVzZXMgdGhlXG4gICAqIGNsaWNrIGV2ZW50IHRvIGJlIGNhbmNlbGxlZCwgc29cbiAgICogbWFudWFsbHkgZmlyZSBvbmUgaGVyZS5cbiAgICovXG4gIHJhZigoKSA9PiBjb21wb25lbnRFbC5jbGljaygpKTtcbiAgLyoqXG4gICAqIElmIGVuYWJsZWQsIHdlIGNhbiBhZGQgc2Nyb2xsIHBhZGRpbmcgdG9cbiAgICogdGhlIGJvdHRvbSBvZiB0aGUgY29udGVudCBzbyB0aGF0IHNjcm9sbCBhc3Npc3RcbiAgICogaGFzIGVub3VnaCByb29tIHRvIHNjcm9sbCB0aGUgaW5wdXQgYWJvdmVcbiAgICogdGhlIGtleWJvYXJkLlxuICAgKi9cbiAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcgJiYgY29udGVudEVsKSB7XG4gICAgY3VycmVudFBhZGRpbmcgPSBzY3JvbGxEYXRhLnNjcm9sbFBhZGRpbmc7XG4gICAgc2V0U2Nyb2xsUGFkZGluZyhjb250ZW50RWwsIGN1cnJlbnRQYWRkaW5nKTtcbiAgfVxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBsZXQgc2Nyb2xsQ29udGVudFRpbWVvdXQ7XG4gICAgY29uc3Qgc2Nyb2xsQ29udGVudCA9IGFzeW5jICgpID0+IHtcbiAgICAgIC8vIGNsZWFuIHVwIGxpc3RlbmVycyBhbmQgdGltZW91dHNcbiAgICAgIGlmIChzY3JvbGxDb250ZW50VGltZW91dCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNsZWFyVGltZW91dChzY3JvbGxDb250ZW50VGltZW91dCk7XG4gICAgICB9XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICAgIC8vIHNjcm9sbCB0aGUgaW5wdXQgaW50byBwbGFjZVxuICAgICAgaWYgKGNvbnRlbnRFbCkge1xuICAgICAgICBhd2FpdCBzY3JvbGxCeVBvaW50KGNvbnRlbnRFbCwgMCwgc2Nyb2xsRGF0YS5zY3JvbGxBbW91bnQsIHNjcm9sbERhdGEuc2Nyb2xsRHVyYXRpb24pO1xuICAgICAgfVxuICAgICAgLy8gdGhlIHNjcm9sbCB2aWV3IGlzIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uIG5vd1xuICAgICAgLy8gZ2l2ZSB0aGUgbmF0aXZlIHRleHQgaW5wdXQgZm9jdXNcbiAgICAgIHJlbG9jYXRlSW5wdXQoY29tcG9uZW50RWwsIGlucHV0RWwsIGZhbHNlLCBzY3JvbGxEYXRhLmlucHV0U2FmZVkpO1xuICAgICAgLy8gZW5zdXJlIHRoaXMgaXMgdGhlIGZvY3VzZWQgaW5wdXRcbiAgICAgIHNldE1hbnVhbEZvY3VzKGlucHV0RWwpO1xuICAgICAgLyoqXG4gICAgICAgKiBXaGVuIHRoZSBpbnB1dCBpcyBhYm91dCB0byBiZSBibHVycmVkXG4gICAgICAgKiB3ZSBzaG91bGQgc2V0IGEgdGltZW91dCB0byByZW1vdmVcbiAgICAgICAqIGFueSBzY3JvbGwgcGFkZGluZy5cbiAgICAgICAqL1xuICAgICAgaWYgKGVuYWJsZVNjcm9sbFBhZGRpbmcpIHtcbiAgICAgICAgc2V0Q2xlYXJTY3JvbGxQYWRkaW5nTGlzdGVuZXIoaW5wdXRFbCwgY29udGVudEVsLCAoKSA9PiAoY3VycmVudFBhZGRpbmcgPSAwKSk7XG4gICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBkb3VibGVLZXlib2FyZEV2ZW50TGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW9uS2V5Ym9hcmREaWRTaG93JywgZG91YmxlS2V5Ym9hcmRFdmVudExpc3RlbmVyKTtcbiAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdpb25LZXlib2FyZERpZFNob3cnLCBzY3JvbGxDb250ZW50KTtcbiAgICB9O1xuICAgIGlmIChjb250ZW50RWwpIHtcbiAgICAgIGNvbnN0IHNjcm9sbEVsID0gYXdhaXQgZ2V0U2Nyb2xsRWxlbWVudChjb250ZW50RWwpO1xuICAgICAgLyoqXG4gICAgICAgKiBzY3JvbGxEYXRhIHdpbGwgb25seSBjb25zaWRlciB0aGUgYW1vdW50IHdlIG5lZWRcbiAgICAgICAqIHRvIHNjcm9sbCBpbiBvcmRlciB0byBwcm9wZXJseSBicmluZyB0aGUgaW5wdXRcbiAgICAgICAqIGludG8gdmlldy4gSXQgd2lsbCBub3QgY29uc2lkZXIgdGhlIGFtb3VudFxuICAgICAgICogd2UgY2FuIHNjcm9sbCBpbiB0aGUgY29udGVudCBlbGVtZW50LlxuICAgICAgICogQXMgYSByZXN1bHQsIHNjcm9sbERhdGEgbWF5IHJlcXVlc3QgYSBncmVhdGVyXG4gICAgICAgKiBzY3JvbGwgcG9zaXRpb24gdGhhbiBpcyBjdXJyZW50bHkgYXZhaWxhYmxlXG4gICAgICAgKiBpbiB0aGUgRE9NLiBJZiB0aGlzIGlzIHRoZSBjYXNlLCB3ZSBuZWVkIHRvXG4gICAgICAgKiB3YWl0IGZvciB0aGUgd2VidmlldyB0byByZXNpemUvdGhlIGtleWJvYXJkXG4gICAgICAgKiB0byBzaG93IGluIG9yZGVyIGZvciBhZGRpdGlvbmFsIHNjcm9sbFxuICAgICAgICogYmFuZHdpZHRoIHRvIGJlY29tZSBhdmFpbGFibGUuXG4gICAgICAgKi9cbiAgICAgIGNvbnN0IHRvdGFsU2Nyb2xsQW1vdW50ID0gc2Nyb2xsRWwuc2Nyb2xsSGVpZ2h0IC0gc2Nyb2xsRWwuY2xpZW50SGVpZ2h0O1xuICAgICAgaWYgKHNjcm9sbERhdGEuc2Nyb2xsQW1vdW50ID4gdG90YWxTY3JvbGxBbW91bnQgLSBzY3JvbGxFbC5zY3JvbGxUb3ApIHtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIE9uIGlPUyBkZXZpY2VzLCB0aGUgc3lzdGVtIHdpbGwgc2hvdyBhIFwiUGFzc3dvcmRzXCIgYmFyIGFib3ZlIHRoZSBrZXlib2FyZFxuICAgICAgICAgKiBhZnRlciB0aGUgaW5pdGlhbCBrZXlib2FyZCBpcyBzaG93bi4gVGhpcyBwcmV2ZW50cyB0aGUgd2VidmlldyBmcm9tIHJlc2l6aW5nXG4gICAgICAgICAqIHVudGlsIHRoZSBcIlBhc3N3b3Jkc1wiIGJhciBpcyBzaG93biwgc28gd2UgbmVlZCB0byB3YWl0IGZvciB0aGF0IHRvIGhhcHBlbiBmaXJzdC5cbiAgICAgICAgICovXG4gICAgICAgIGlmIChpbnB1dEVsLnR5cGUgPT09ICdwYXNzd29yZCcpIHtcbiAgICAgICAgICAvLyBBZGQgNTBweCB0byBhY2NvdW50IGZvciB0aGUgXCJQYXNzd29yZHNcIiBiYXJcbiAgICAgICAgICBzY3JvbGxEYXRhLnNjcm9sbEFtb3VudCArPSBTQ1JPTExfQU1PVU5UX1BBRERJTkc7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIGRvdWJsZUtleWJvYXJkRXZlbnRMaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ2lvbktleWJvYXJkRGlkU2hvdycsIHNjcm9sbENvbnRlbnQpO1xuICAgICAgICB9XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBUaGlzIHNob3VsZCBvbmx5IGZpcmUgaW4gMiBpbnN0YW5jZXM6XG4gICAgICAgICAqIDEuIFRoZSBhcHAgaXMgdmVyeSBzbG93LlxuICAgICAgICAgKiAyLiBUaGUgYXBwIGlzIHJ1bm5pbmcgaW4gYSBicm93c2VyIG9uIGFuIG9sZCBPU1xuICAgICAgICAgKiB0aGF0IGRvZXMgbm90IHN1cHBvcnQgSW9uaWMgS2V5Ym9hcmQgRXZlbnRzXG4gICAgICAgICAqL1xuICAgICAgICBzY3JvbGxDb250ZW50VGltZW91dCA9IHNldFRpbWVvdXQoc2Nyb2xsQ29udGVudCwgMTAwMCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgc2Nyb2xsQ29udGVudCgpO1xuICB9XG59O1xuXG5jb25zdCBJTlBVVF9CTFVSUklORyA9IHRydWU7XG5jb25zdCBzdGFydElucHV0U2hpbXMgPSBhc3luYyAoY29uZmlnLCBwbGF0Zm9ybSkgPT4ge1xuICBjb25zdCBkb2MgPSBkb2N1bWVudDtcbiAgY29uc3QgaXNJT1MgPSBwbGF0Zm9ybSA9PT0gJ2lvcyc7XG4gIGNvbnN0IGlzQW5kcm9pZCA9IHBsYXRmb3JtID09PSAnYW5kcm9pZCc7XG4gIC8qKlxuICAgKiBIaWRlIENhcmV0IGFuZCBJbnB1dCBCbHVycmluZyBhcmUgbmVlZGVkIG9uIGlPUy5cbiAgICogU2Nyb2xsIEFzc2lzdCBhbmQgU2Nyb2xsIFBhZGRpbmcgYXJlIG5lZWRlZCBvbiBpT1MgYW5kIEFuZHJvaWRcbiAgICogd2l0aCBDaHJvbWUgd2ViIGJyb3dzZXIgKG5vdCBDaHJvbWUgd2VidmlldykuXG4gICAqL1xuICBjb25zdCBrZXlib2FyZEhlaWdodCA9IGNvbmZpZy5nZXROdW1iZXIoJ2tleWJvYXJkSGVpZ2h0JywgMjkwKTtcbiAgY29uc3Qgc2Nyb2xsQXNzaXN0ID0gY29uZmlnLmdldEJvb2xlYW4oJ3Njcm9sbEFzc2lzdCcsIHRydWUpO1xuICBjb25zdCBoaWRlQ2FyZXQgPSBjb25maWcuZ2V0Qm9vbGVhbignaGlkZUNhcmV0T25TY3JvbGwnLCBpc0lPUyk7XG4gIGNvbnN0IGlucHV0Qmx1cnJpbmcgPSBjb25maWcuZ2V0Qm9vbGVhbignaW5wdXRCbHVycmluZycsIGlzSU9TKTtcbiAgY29uc3Qgc2Nyb2xsUGFkZGluZyA9IGNvbmZpZy5nZXRCb29sZWFuKCdzY3JvbGxQYWRkaW5nJywgdHJ1ZSk7XG4gIGNvbnN0IGlucHV0cyA9IEFycmF5LmZyb20oZG9jLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lvbi1pbnB1dCwgaW9uLXRleHRhcmVhJykpO1xuICBjb25zdCBoaWRlQ2FyZXRNYXAgPSBuZXcgV2Vha01hcCgpO1xuICBjb25zdCBzY3JvbGxBc3Npc3RNYXAgPSBuZXcgV2Vha01hcCgpO1xuICAvKipcbiAgICogR3JhYiB0aGUgbmF0aXZlIGtleWJvYXJkIHJlc2l6ZSBjb25maWd1cmF0aW9uXG4gICAqIGFuZCBwYXNzIGl0IHRvIHNjcm9sbCBhc3Npc3QuIFNjcm9sbCBhc3Npc3QgcmVxdWlyZXNcbiAgICogdGhhdCB3ZSBhZGp1c3QgdGhlIGlucHV0IHJpZ2h0IGJlZm9yZSB0aGUgaW5wdXRcbiAgICogaXMgYWJvdXQgdG8gYmUgZm9jdXNlZC4gSWYgd2UgY2FsbGVkIGBLZXlib2FyZC5nZXRSZXNpemVNb2RlYFxuICAgKiBvbiBmb2N1c2luIGluIHNjcm9sbCBhc3Npc3QsIHdlIGNvdWxkIHBvdGVudGlhbGx5IGFkanVzdCB0aGVcbiAgICogaW5wdXQgdG9vIGxhdGUgc2luY2UgdGhpcyBjYWxsIGlzIGFzeW5jLlxuICAgKi9cbiAgY29uc3Qga2V5Ym9hcmRSZXNpemVNb2RlID0gYXdhaXQgS2V5Ym9hcmQuZ2V0UmVzaXplTW9kZSgpO1xuICBjb25zdCByZWdpc3RlcklucHV0ID0gYXN5bmMgKGNvbXBvbmVudEVsKSA9PiB7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IGNvbXBvbmVudE9uUmVhZHkoY29tcG9uZW50RWwsIHJlc29sdmUpKTtcbiAgICBjb25zdCBpbnB1dFJvb3QgPSBjb21wb25lbnRFbC5zaGFkb3dSb290IHx8IGNvbXBvbmVudEVsO1xuICAgIGNvbnN0IGlucHV0RWwgPSBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcignaW5wdXQnKSB8fCBpbnB1dFJvb3QucXVlcnlTZWxlY3RvcigndGV4dGFyZWEnKTtcbiAgICBjb25zdCBzY3JvbGxFbCA9IGZpbmRDbG9zZXN0SW9uQ29udGVudChjb21wb25lbnRFbCk7XG4gICAgY29uc3QgZm9vdGVyRWwgPSAhc2Nyb2xsRWwgPyBjb21wb25lbnRFbC5jbG9zZXN0KCdpb24tZm9vdGVyJykgOiBudWxsO1xuICAgIGlmICghaW5wdXRFbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISFzY3JvbGxFbCAmJiBoaWRlQ2FyZXQgJiYgIWhpZGVDYXJldE1hcC5oYXMoY29tcG9uZW50RWwpKSB7XG4gICAgICBjb25zdCBybUZuID0gZW5hYmxlSGlkZUNhcmV0T25TY3JvbGwoY29tcG9uZW50RWwsIGlucHV0RWwsIHNjcm9sbEVsKTtcbiAgICAgIGhpZGVDYXJldE1hcC5zZXQoY29tcG9uZW50RWwsIHJtRm4pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBkYXRlL2RhdGV0aW1lLWxvY2FsZSBpbnB1dHMgb24gbW9iaWxlIGRldmljZXMgc2hvdyBkYXRlIHBpY2tlclxuICAgICAqIG92ZXJsYXlzIGluc3RlYWQgb2Yga2V5Ym9hcmRzLiBBcyBhIHJlc3VsdCwgc2Nyb2xsIGFzc2lzdCBpc1xuICAgICAqIG5vdCBuZWVkZWQuIFRoaXMgYWxzbyB3b3JrcyBhcm91bmQgYSBidWcgaW4gaU9TIDwxNiB3aGVyZVxuICAgICAqIHNjcm9sbCBhc3Npc3QgY2F1c2VzIHRoZSBicm93c2VyIHRvIGxvY2sgdXAuIFNlZSBGVy0xOTk3LlxuICAgICAqL1xuICAgIGNvbnN0IGlzRGF0ZUlucHV0ID0gaW5wdXRFbC50eXBlID09PSAnZGF0ZScgfHwgaW5wdXRFbC50eXBlID09PSAnZGF0ZXRpbWUtbG9jYWwnO1xuICAgIGlmICghaXNEYXRlSW5wdXQgJiZcbiAgICAgICghIXNjcm9sbEVsIHx8ICEhZm9vdGVyRWwpICYmXG4gICAgICBzY3JvbGxBc3Npc3QgJiZcbiAgICAgICFzY3JvbGxBc3Npc3RNYXAuaGFzKGNvbXBvbmVudEVsKSkge1xuICAgICAgY29uc3Qgcm1GbiA9IGVuYWJsZVNjcm9sbEFzc2lzdChjb21wb25lbnRFbCwgaW5wdXRFbCwgc2Nyb2xsRWwsIGZvb3RlckVsLCBrZXlib2FyZEhlaWdodCwgc2Nyb2xsUGFkZGluZywga2V5Ym9hcmRSZXNpemVNb2RlLCBpc0FuZHJvaWQpO1xuICAgICAgc2Nyb2xsQXNzaXN0TWFwLnNldChjb21wb25lbnRFbCwgcm1Gbik7XG4gICAgfVxuICB9O1xuICBjb25zdCB1bnJlZ2lzdGVySW5wdXQgPSAoY29tcG9uZW50RWwpID0+IHtcbiAgICBpZiAoaGlkZUNhcmV0KSB7XG4gICAgICBjb25zdCBmbiA9IGhpZGVDYXJldE1hcC5nZXQoY29tcG9uZW50RWwpO1xuICAgICAgaWYgKGZuKSB7XG4gICAgICAgIGZuKCk7XG4gICAgICB9XG4gICAgICBoaWRlQ2FyZXRNYXAuZGVsZXRlKGNvbXBvbmVudEVsKTtcbiAgICB9XG4gICAgaWYgKHNjcm9sbEFzc2lzdCkge1xuICAgICAgY29uc3QgZm4gPSBzY3JvbGxBc3Npc3RNYXAuZ2V0KGNvbXBvbmVudEVsKTtcbiAgICAgIGlmIChmbikge1xuICAgICAgICBmbigpO1xuICAgICAgfVxuICAgICAgc2Nyb2xsQXNzaXN0TWFwLmRlbGV0ZShjb21wb25lbnRFbCk7XG4gICAgfVxuICB9O1xuICBpZiAoaW5wdXRCbHVycmluZyAmJiBJTlBVVF9CTFVSUklORykge1xuICAgIGVuYWJsZUlucHV0Qmx1cnJpbmcoKTtcbiAgfVxuICAvLyBJbnB1dCBtaWdodCBiZSBhbHJlYWR5IGxvYWRlZCBpbiB0aGUgRE9NIGJlZm9yZSBpb24tZGV2aWNlLWhhY2tzIGRpZC5cbiAgLy8gQXQgdGhpcyBwb2ludCB3ZSBuZWVkIHRvIGxvb2sgZm9yIGFsbCBvZiB0aGUgaW5wdXRzIG5vdCByZWdpc3RlcmVkIHlldFxuICAvLyBhbmQgcmVnaXN0ZXIgdGhlbS5cbiAgZm9yIChjb25zdCBpbnB1dCBvZiBpbnB1dHMpIHtcbiAgICByZWdpc3RlcklucHV0KGlucHV0KTtcbiAgfVxuICAvLyBUT0RPKEZXLTI4MzIpOiB0eXBlc1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRMb2FkJywgKChldikgPT4ge1xuICAgIHJlZ2lzdGVySW5wdXQoZXYuZGV0YWlsKTtcbiAgfSkpO1xuICBkb2MuYWRkRXZlbnRMaXN0ZW5lcignaW9uSW5wdXREaWRVbmxvYWQnLCAoKGV2KSA9PiB7XG4gICAgdW5yZWdpc3RlcklucHV0KGV2LmRldGFpbCk7XG4gIH0pKTtcbn07XG5cbmV4cG9ydCB7IHN0YXJ0SW5wdXRTaGltcyB9O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9